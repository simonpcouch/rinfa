[{"path":"https://simonpcouch.github.io/rinfa/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 rinfa authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://simonpcouch.github.io/rinfa/articles/benchmarks.html","id":"linear-regression","dir":"Articles","previous_headings":"","what":"Linear regression","title":"Benchmarks","text":"first model type, ’ll write code ’m using benchmark model fits. , ’ll just plot results without showing code. First, setting parameters experiment—modeling engine fit models following number rows: Now, ’ll grab different possible engines parsnip’s model environment. parsnip supports fitting models following engines: Now, set data.frame() drop experimental results load packages needed fit different models. engine, put together model specification, iterate various numbers rows training data. generating dataset many rows, measure long model fit takes store linear_reg_timings data frame.","code":"n_rows <- round(10^seq(2, 6, .5))  n_rows #> [1]     100     316    1000    3162   10000   31623  100000  316228 1000000 engines <- unique(get_model_env()[[\"linear_reg_fit\"]]$engine) engines #> [1] \"lm\"     \"glm\"    \"glmnet\" \"stan\"   \"spark\"  \"keras\"  \"brulee\" \"linfa\" linear_reg_timings <-    data.frame(     engine = character(),      n_row = integer(),      timing = numeric()   )  x <- lapply(engines, function(engine) {   pkgs <- required_pkgs(linear_reg(engine = engine))   lapply(pkgs, require, character.only = TRUE) }) for (engine in engines) {   spec <- linear_reg(engine = engine)   if (engine == \"glmnet\") {     spec <- spec %>% set_args(penalty = 0)   }   if (engine == \"spark\") {     next   }   for (n_row in n_rows) {     # first, check that a previous run didn't take too long;      # if it did, go ahead and skip it     longest_fit <- linear_reg_timings[linear_reg_timings$engine == engine,]     longest_fit <- max(longest_fit$timing)          if (longest_fit > 600) next      set.seed(1)     d <- sim_regression(n_row)          # The following blurb is atypical in a tidymodels workflow, but     # feels worth including to give each engine a fair shot. We extract the     # \"encoding,\" i.e. whether the model takes (matrix) x and y arguments or     # a data.frame and a formula. The elapsed time to convert from data.frame     # to matrix or vice versa is non-negligible for quicker model fits.     #     # Normally, a user would just call whichever fit interface feels more     # comfortable for them and tidymodels would take care of the conversion.     fit_encoding <- get_fit(\"linear_reg\")     fit_encoding <- fit_encoding[fit_encoding$engine == engine, \"value\"]     fit_encoding <- fit_encoding$value[[1]]$interface          if (!identical(fit_encoding, \"matrix\")) {       timing <- system.time(fit(spec, outcome ~ ., d))     } else {       x <- as.matrix(d[-1])       timing <- system.time(fit_xy(spec, x = x, y = d$outcome))     }          linear_reg_timings <-       bind_rows(         linear_reg_timings,         data.frame(engine = engine, n_row = n_row, timing = timing[[\"elapsed\"]])       )   } } linear_reg_timings %>%   ggplot() +   aes(x = n_row, y = timing, colour = engine, group = engine) +   geom_line() +   scale_y_log10() +   scale_x_log10() +   labs(x = \"Log(# rows)\", y = \"Log(Fit time, seconds)\")"},{"path":"https://simonpcouch.github.io/rinfa/articles/benchmarks.html","id":"logistic-regression","dir":"Articles","previous_headings":"","what":"Logistic regression","title":"Benchmarks","text":"","code":"logistic_reg_timings %>%   ggplot() +   aes(x = n_row, y = timing, colour = engine, group = engine) +   geom_line() +   scale_y_log10() +   scale_x_log10() +   labs(x = \"# rows\", y = \"Log(Fit time, seconds)\")"},{"path":"https://simonpcouch.github.io/rinfa/articles/benchmarks.html","id":"multinomial-regression","dir":"Articles","previous_headings":"","what":"Multinomial regression","title":"Benchmarks","text":"","code":"multinom_reg_timings %>%   ggplot() +   aes(x = n_row, y = timing, colour = engine, group = engine) +   geom_line() +   scale_y_log10() +   scale_x_log10() +   labs(x = \"# rows\", y = \"Log(Fit time, seconds)\")"},{"path":"https://simonpcouch.github.io/rinfa/articles/benchmarks.html","id":"decision-trees","dir":"Articles","previous_headings":"","what":"Decision trees","title":"Benchmarks","text":"","code":"decision_tree_timings %>%   ggplot() +   aes(x = n_row, y = timing, colour = engine, group = engine) +   geom_line() +   scale_y_log10() +   scale_x_log10() +   labs(x = \"# rows\", y = \"Log(Fit time, seconds)\")"},{"path":"https://simonpcouch.github.io/rinfa/articles/benchmarks.html","id":"naive-bayes","dir":"Articles","previous_headings":"","what":"Naive bayes","title":"Benchmarks","text":"","code":"naive_Bayes_timings %>%   ggplot() +   aes(x = n_row, y = timing, colour = engine, group = engine) +   geom_line() +   scale_y_log10() +   scale_x_log10() +   labs(x = \"# rows\", y = \"Log(Fit time, seconds)\")"},{"path":"https://simonpcouch.github.io/rinfa/articles/benchmarks.html","id":"support-vector-machines","dir":"Articles","previous_headings":"","what":"Support vector machines","title":"Benchmarks","text":"","code":"svm_linear_timings %>%   ggplot() +   aes(x = n_row, y = timing, colour = engine, group = engine) +   geom_line() +   scale_y_log10() +   scale_x_log10() +   labs(x = \"# rows\", y = \"Log(Fit time, seconds)\")"},{"path":"https://simonpcouch.github.io/rinfa/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Simon Couch. Author, maintainer. Josiah Parry. Author.","code":""},{"path":"https://simonpcouch.github.io/rinfa/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Couch S, Parry J (2024). rinfa: Rust bindings tidymodels. R package version 0.0.0.9000, https://simonpcouch.github.io/rinfa/, https://github.com/simonpcouch/rinfa.","code":"@Manual{,   title = {rinfa: Rust bindings for tidymodels},   author = {Simon Couch and Josiah Parry},   year = {2024},   note = {R package version 0.0.0.9000, https://simonpcouch.github.io/rinfa/},   url = {https://github.com/simonpcouch/rinfa}, }"},{"path":"https://simonpcouch.github.io/rinfa/index.html","id":"rinfa","dir":"","previous_headings":"","what":"Rust bindings for tidymodels","title":"Rust bindings for tidymodels","text":"goal rinfa provide Rust bindings parsnip model specifications.","code":""},{"path":"https://simonpcouch.github.io/rinfa/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Rust bindings for tidymodels","text":"can install development version rinfa GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"simonpcouch/rinfa\")"},{"path":"https://simonpcouch.github.io/rinfa/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Rust bindings for tidymodels","text":"use rinfa tidymodels, set modeling engine \"linfa\":","code":"x <- matrix(rnorm(3e7), ncol = 3, dimnames = list(NULL, paste0(\"X\", 1:3))) y <- rnorm(1e7)  dat <- cbind(as.data.frame(x), y)  system.time(   lm(y ~ ., dat) ) #>    user  system elapsed  #>   1.554   0.229   1.791  system.time(   # lm()'s speedy friend, from base R   .lm.fit(x, y) ) #>    user  system elapsed  #>   0.398   0.021   0.420  library(rinfa)  system.time({   .linfa_linear_reg(x, y) }) #>    user  system elapsed  #>   0.208   0.083   0.297 # using the formula interface: linfa_fit <- fit(linear_reg(engine = \"linfa\"), y ~ ., dat)  # using the (more performant, in this case) XY interface: linfa_fit_xy <- fit_xy(linear_reg(engine = \"linfa\"), x = x, y = y)"},{"path":"https://simonpcouch.github.io/rinfa/index.html","id":"available-implementations","dir":"","previous_headings":"","what":"Available implementations","title":"Rust bindings for tidymodels","text":"rinfa package provides additional engine \"linfa\" models following table:","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_decision_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Decision trees with linfa — .linfa_decision_tree","title":"Decision trees with linfa — .linfa_decision_tree","text":"internal function interfaces directly Rust implementation linfa. preferred entry point via tidymodels, .e. :","code":"model_spec <- decision_tree(engine = \"linfa\", mode = \"classification\") model <- fit(model_spec, as.factor(vs) ~ ., mtcars)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_decision_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decision trees with linfa — .linfa_decision_tree","text":"","code":".linfa_decision_tree(x, y, cost_complexity = 1e-05, tree_depth = 7L, min_n = 4)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_decision_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decision trees with linfa — .linfa_decision_tree","text":"x numeric matrix predictors. y integer vector outcome values. cost_complexity positive number cost/complexity parameter (.k.. Cp) used CART models (specific engines ). tree_depth integer maximum depth tree. min_n integer minimum number data points node required node split .","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_decision_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Decision trees with linfa — .linfa_decision_tree","text":"","code":"x <- matrix(rnorm(300), ncol = 3) y <- sample(1:4, size = 100, replace = TRUE)  m <- .linfa_decision_tree(x, y) m #> A decision_tree fitted with linfa.  predict(m, matrix(rnorm(12), ncol = 3)) #> [1] 1 4 2 4"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_linear_reg.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear regression with linfa — .linfa_linear_reg","title":"Linear regression with linfa — .linfa_linear_reg","text":"internal function interfaces directly Rust implementation linfa. preferred entry point via tidymodels, .e. :","code":"model_spec <- linear_reg(engine = \"linfa\") model <- fit(model_spec, mpg ~ ., mtcars)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_linear_reg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear regression with linfa — .linfa_linear_reg","text":"","code":".linfa_linear_reg(x, y)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_linear_reg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear regression with linfa — .linfa_linear_reg","text":"x numeric matrix predictors. y numeric vector outcome values.","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_linear_reg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear regression with linfa — .linfa_linear_reg","text":"","code":"x <- matrix(rnorm(300), ncol = 3) y <- rnorm(100)  m <- .linfa_linear_reg(x, y) m #> A linear_reg fitted with linfa.  predict(m, matrix(rnorm(12), ncol = 3)) #> [1] -0.37904704 -0.21636341  0.21567260  0.09364324"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_logistic_reg.html","id":null,"dir":"Reference","previous_headings":"","what":"Logistic regression with linfa — .linfa_logistic_reg","title":"Logistic regression with linfa — .linfa_logistic_reg","text":"internal function interfaces directly Rust implementation linfa. preferred entry point via tidymodels, .e. :","code":"model_spec <- decision_tree(engine = \"linfa\", mode = \"classification\") model <- fit(model_spec, as.factor(vs) ~ ., mtcars)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_logistic_reg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logistic regression with linfa — .linfa_logistic_reg","text":"","code":".linfa_logistic_reg(x, y)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_logistic_reg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logistic regression with linfa — .linfa_logistic_reg","text":"x numeric matrix predictors. y integer vector outcome values.","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_logistic_reg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logistic regression with linfa — .linfa_logistic_reg","text":"","code":"x <- matrix(rnorm(300), ncol = 3) y <- sample(1:2, size = 100, replace = TRUE)  m <- .linfa_logistic_reg(x, y) m #> A logistic_reg fitted with linfa.  predict(m, matrix(rnorm(12), ncol = 3)) #> [1] 1 1 1 1"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_multinom_reg.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial regression with linfa — .linfa_multinom_reg","title":"Multinomial regression with linfa — .linfa_multinom_reg","text":"internal function interfaces directly Rust implementation linfa. preferred entry point via tidymodels, .e. :","code":"model_spec <- multinom_reg(engine = \"linfa\", mode = \"classification\") model <- fit(model_spec, as.factor(cyl) ~ ., mtcars)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_multinom_reg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial regression with linfa — .linfa_multinom_reg","text":"","code":".linfa_multinom_reg(x, y)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_multinom_reg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial regression with linfa — .linfa_multinom_reg","text":"x numeric matrix predictors. y integer vector outcome values.","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_multinom_reg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multinomial regression with linfa — .linfa_multinom_reg","text":"","code":"x <- matrix(rnorm(300), ncol = 3) y <- sample(1:4, size = 100, replace = TRUE)  m <- .linfa_multinom_reg(x, y) m #> A multinom_reg fitted with linfa.  predict(m, matrix(rnorm(12), ncol = 3)) #> [1] 2 4 2 4"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_naive_Bayes.html","id":null,"dir":"Reference","previous_headings":"","what":"Naive bayes with linfa — .linfa_naive_Bayes","title":"Naive bayes with linfa — .linfa_naive_Bayes","text":"internal function interfaces directly Rust implementation linfa. preferred entry point via tidymodels, .e. :","code":"model_spec <- naive_Bayes(engine = \"linfa\", mode = \"classification\") model <- fit(model_spec, as.factor(cyl) ~ ., mtcars)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_naive_Bayes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Naive bayes with linfa — .linfa_naive_Bayes","text":"","code":".linfa_naive_Bayes(x, y, smoothness = 1e-09)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_naive_Bayes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Naive bayes with linfa — .linfa_naive_Bayes","text":"x numeric matrix predictors. y integer vector outcome values. smoothness non-negative number representing relative smoothness class boundary. Smaller examples result model flexible boundaries larger values generate class boundaries less adaptable","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_naive_Bayes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Naive bayes with linfa — .linfa_naive_Bayes","text":"","code":"x <- matrix(rnorm(300), ncol = 3) y <- sample(1:4, size = 100, replace = TRUE)  m <- .linfa_naive_Bayes(x, y) m #> A naive_Bayes fitted with linfa.  predict(m, matrix(rnorm(12), ncol = 3)) #> [1] 4 4 2 2"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_svm_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Support vector machines with linfa — .linfa_svm_linear","title":"Support vector machines with linfa — .linfa_svm_linear","text":"internal function interfaces directly Rust implementation linfa. preferred entry point via tidymodels, .e. :","code":"model_spec <- svm_linear(engine = \"linfa\", mode = \"classification\") model <- fit(model_spec, as.factor(vs) ~ ., mtcars)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_svm_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Support vector machines with linfa — .linfa_svm_linear","text":"","code":".linfa_svm_linear(x, y, cost = 1)"},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_svm_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Support vector machines with linfa — .linfa_svm_linear","text":"x numeric matrix predictors. y logical vector outcome values. cost positive number cost predicting sample within wrong side margin","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/dot-linfa_svm_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Support vector machines with linfa — .linfa_svm_linear","text":"","code":"x <- matrix(rnorm(300), ncol = 3) y <- sample(c(0L, 1L), size = 100, replace = TRUE)  m <- .linfa_svm_linear(x, y) m #> A svm_linear fitted with linfa.  predict(m, matrix(rnorm(12), ncol = 3)) #> [1] 1 1 1 1"},{"path":"https://simonpcouch.github.io/rinfa/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. stats predict","code":""},{"path":"https://simonpcouch.github.io/rinfa/reference/rinfa-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rinfa: Rust bindings for tidymodels — rinfa-package","title":"rinfa: Rust bindings for tidymodels — rinfa-package","text":"'parsnip' extension interfaces 'Rust' machine learning library 'linfa' decrease model fit times common model types.","code":""},{"path":[]},{"path":"https://simonpcouch.github.io/rinfa/reference/rinfa-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rinfa: Rust bindings for tidymodels — rinfa-package","text":"Maintainer: Simon Couch simon.couch@posit.co Authors: Josiah Parry josiah.parry@gmail.com (ORCID)","code":""}]
